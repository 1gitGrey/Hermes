<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Hermes by New-Bamboo</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Hermes</h1>
        <p class="header">An environment for Ruby and JS developers in Darwin</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/New-Bamboo/Hermes/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/New-Bamboo/Hermes/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/New-Bamboo/Hermes">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/New-Bamboo">New-Bamboo</a></p>


      </header>
      <section>
        <h1>Hermes</h1>

<p>Hermes is an environment for Ruby and JavaScript developers in Darwin using
<a href="http://tmux.sourceforge.net/">Tmux</a>, <a href="http://www.vim.org/">Vim</a> and <a href="http://www.iterm2.com/">iTerm
2</a> that focuses on speed and ease of use.</p>

<p>Hermes is opinionated where having an opinion is important, but does not
prevent you from customizing your tools.</p>

<p>Hermes gives you a lot of things for free:</p>

<ul>
<li>Sensible defaults for developers.</li>
<li>Integration of Vim into tmux and tmux into iTerm 2.</li>
<li>Mouse and window integration, allowing selections within tmux and Vim panes,
not across them.</li>
<li>Vim packages that provide git integration, command- and block-completion,
fuzzy file search and ease of testing.</li>
</ul><p>We feel that good documentation is a key part of using any new technology with
lots of moving parts, so we will be improving Hermes' documentation in the days
and weeks to come.</p>

<p><img src="https://raw.github.com/New-Bamboo/Hermes/master/hermes.png" alt="Hermes screenshot"></p>

<h2>Preliminary Thanks</h2>

<p>Hermes combines plugins, settings, snippets, gists, and ideas from countless
developers around the world. We would like to thank:</p>

<ul>
<li>The <a href="http://www.vim.org/">Vim</a> team.</li>
<li>The <a href="http://tmux.sourceforge.net/">Tmux</a> team.</li>
<li>The <a href="http://www.gnu.org/software/bash/bash.html">GNU Bash</a> and <a href="http://ridiculousfish.com/shell/">Fish</a> teams</li>
<li>The <a href="http://mxcl.github.com/homebrew/">Homebrew</a> team.</li>
<li>
<a href="http://tpo.pe/">Tim Pope</a>. Seriously, you're awesome.</li>
<li>
<a href="http://thoughtbot.com/">Thoughtbot</a> for their dotfiles, essential in getting
the Tmux configuration right.</li>
<li>
<a href="http://vimcasts.org/">Vimcasts</a>, for showing the world just how powerful Vim can be.</li>
</ul><h2>Installation</h2>

<p><strong>Warning!</strong> Hermes is still early in development, so just to be
careful, we strongly encourage you to install it in a separate
user account, not your main one. That said, we <em>have</em> tested it on
our own user accounts, where it worked just fine.</p>

<h3>Prerequisites</h3>

<p>Hermes relies on Homebrew and RVM to work properly. While Homebrew is a de
facto standard developers using OS X, there are a good number of people that
use RBenv, so support for that is in the pipeline. We are happy to look at any
pull requests.</p>

<p>If these two tools are not available, the installer script will halt. Please
refer to these tools' excellent documentation for installation instructions.</p>

<h3>Fork first!</h3>

<p>As the very first step, you should fork the Hermes on Github since this will
make it easier for you to customize your installation. After you're done, you
can run:</p>

<pre><code>mkdir -p ~/.hermes
git clone https://github.com/&lt;your_github_username&gt;/Hermes.git ~/.hermes
cd ~/.hermes
./install.bash
</code></pre>

<p>This will perform the following actions:</p>

<ul>
<li>Check that you have all the needed Homebrew dependencies</li>
<li>Back up any file or folder that would be overwritten by the installer process</li>
<li>Install all dotfiles and plugins available in the <code>hermes</code> directory and
symlink them to the right locations in your home folder</li>
</ul><p>You may also want to add Hermes's repository as an upstream repository, so you
can pull in the changes done on the main trunk whenever you need to.</p>


<p><img src="https://raw.github.com/New-Bamboo/Hermes/master/hermes-install.png" alt="Hermes installation"></p>

<h3>What's included in the installer</h3>

<p>The installer will:</p>

<ul>
<li>check for dependencies</li>
<li>backup any existing dotfile that would be overwritten in a timestamped tar
file that you can use to restore your previous configuration</li>
<li>install a number of required Homebrew packages</li>
<li>create a <code>~/hermes</code> directory and symlink its content to your home folder
where every piece of software expects to find its main configuration file(s)</li>
</ul><p>Hermes includes:</p>

<ul>
<li>configuration and plugins for Vim</li>
<li>configuration for Tmux</li>
<li>configuration for git</li>
<li>configuration and additional functionality for two shells: Bash and Fish.</li>
<li>settings for <code>gem</code>, <code>ack</code>, <code>pow</code>, <code>pry</code> and <code>irb</code>
</li>
</ul><p>In addition, Hermes glues all components together so they play nicely with each
other and the OS. Two examples of this integration are are Hermes' support for
the system clipboard in OS X and window/pane aware mouse integration.</p>

<h3>Updates</h3>

<p>Being a git-based project, you can update Hermes by simply pulling from the
remote. If you forked the project, please remember to add the original repo as
an upstream repository to make getting new project updates easier.</p>

<h2>How it's built</h2>

<p>Hermes' goal is to provide a solid structure for you to build on top of without
having to deal with any intermediate configuration layers.  For example, Vim's
entire configuration is managed canonically through the <code>~/.vimrc</code> file and the
<code>~/.vim</code> folder. The only significant difference is that under the hood, those
files are actually symlinks to your <code>hermes</code> folder.</p>

<p>Knowing how Hermes ties everything together is useful when it comes time to
configure it.</p>

<h3>Vim</h3>

<p>A stock vim installation with a basic configuration can go a long way and can
be really beneficial when it comes to editing files on a server.</p>

<p>There is however a very simple problem with the default Vim installation that
OS X provides: it cannot access the system clipboard. That means if you copy
anything from outside the editor, it's not available in any of Vim's registers.
Worse yet, if you copy anything in Vim using its internal commands, it won't be
available to the rest of the system</p>

<p>To sort this out, Hermes installs Homebrew's version of Vim, which is
available through the MacVim package:</p>

<pre><code>brew install macvim --override-system-vim
</code></pre>

<p>This has some additional benefits, like having support for Ruby in plugins.</p>

<p>Let's now go with some defaults for a basic <code>.vimrc</code> file:</p>

<pre><code>set nocompatible    "don't need Vi compatibility
set nobackup        "don't create backup files
set nowritebackup
set notimeout
set ttimeout
set ttimeoutlen=10
set noswapfile      "don't create swap files
set history=50      "keep a small history
set ruler           "always show position
set showcmd
set incsearch
set laststatus=2    "full status bar
set t_Co=256        "256 colors - requires a properly configured terminal emulator
syntax on           "turn syntax highlight on

filetype plugin indent on "let plugins manage indentation

" Send more characters for redraws
set ttyfast
" Enable mouse use in all modes
set mouse=a
set ttymouse=xterm2

" Fix backspace
set backspace=indent,eol,start
fixdel

" Softtabs, 2 spaces
set tabstop=2
set shiftwidth=2
set expandtab

" Display extra whitespace at the end of the line
set list listchars=tab:»·,trail:·
" Clipboard fix for OsX
set clipboard=unnamed

" Numbers
set number
set numberwidth=2

"Folding
set foldmethod=indent
set foldlevelstart=99

" Autocompletion options
set wildmode=list:longest,list:full
set complete=.,w,b"
</code></pre>

<p>These settings will allow you to efficiently edit any file whose type is
supported by default, so Javascript and Ruby are already covered. The settings
enable standard features like line numbering and syntax highlighting and also
turn on features like mouse support and clipboard sharing that are useful in
integrating Vim into iTerm and OS X.</p>

<h4>Plugins</h4>

<p>Plugins are a powerful way to extend Vim's capabilities. The implementation may
change, but we feel you should be able to expect the following from a modern
text editor:</p>

<ul>
<li>Support for fuzzy search inside a directory tree. You should be able to
easily open a file by name without navigating the tree.</li>
<li>Full text search inside a directory tree.</li>
<li>Snippet support with expansion, tab stops and completion. Like Textmate.</li>
<li>Integration with testing frameworks. You should be able to run tests without
leaving the editor.</li>
<li>Tabs and split windows. You should be able to see tests and the corresponding
code at the same time and be able to easily switch from one to the other.</li>
<li>Language specific features, like syntax-aware indentation and navigation.</li>
</ul><p>Needless to say, a number of other text editors support these features. Vim,
however, combines this with its extremely efficient modal editing approach.</p>

<p>Hermes provides a good number of plugins, aiming to strike a balance between
features and speed. You can see the complete list under <code>hermes/vim/bundle</code>,
but here are some highlights:</p>

<ul>
<li>
<a href="https://github.com/kien/ctrlp.vim">Ctrlp</a>: a tool for fuzzy searching by
file and tag.</li>
<li>
<a href="https://github.com/msanders/snipmate.vim">Snipmate</a>: unashamedly borrowing
from Textmate, Snipmate provides tab completion based on snippet files.</li>
<li>
<a href="https://github.com/epmatsw/ag.vim">The silver searcher</a>: <code>ag</code> is a faster
alternative to Ack.</li>
<li>
<a href="https://github.com/vim-scripts/tComment">TComment</a>: toggles comments in
nearly any language.</li>
<li>
<a href="https://github.com/tpope/vim-rails">Rails.vim</a>: provides shortcuts,
generators and settings for working with Ruby on Rails projects.  Absolutely
killer.</li>
<li>
<a href="https://github.com/benmills/vimux">Vimux</a>: forms a bridge with Tmux to send
text and commands to a Tmux pane. Vimux is essential for Hermes' testing
support.</li>
</ul><p>However, we encourage you to be wary of plugins for several reasons:</p>

<ul>
<li>Vim has many conventional ways to accomplish certain tasks, and while it's
possible to do things in many ways, it's important to try to understand the
Vim way of doing things and play to its strengths.</li>
<li>One of Vim's benefits is speed and low memory footprint, making it responsive
even when opening huge files. Increasing Vim's footprint through exxcessive
numbers of plugins can eliminate this benefit.</li>
<li>Sometimes a plugin is not necessary. Similar or identical effects can often
be achieved with smaller, well thought-out changes in your .vimrc.</li>
<li>Although powerful, Vim is a text editor and should do just this one job well.</li>
</ul><p>Vim's approach to plugin management is a little counterintuitive:
by default, Vim looks for additional scripts to load in <code>~/.vim</code>,
which has subfolders that determine when the configuration is
loaded. For example, a script can be split across the <code>plugin</code> and
the <code>autoload</code> directories, the former for the bulk, load-once
functionality while the latter for anything that requires constant
recalculation. This means that a manual installation may be spread
across multiple directories, resulting in a structure that is
difficult to maintain and update.</p>

<p>Enter <a href="https://github.com/tpope/vim-pathogen">Pathogen</a>, a package
manager that makes this process painless and that inverts the
usual installation pattern, as it lets you organize plugins based
on their name. With Pathogen, you can simply clone a repository into
your <code>~/.vim</code> folder and you're done. This is the first stepping
stone to efficient dotfile management through a git repository
where you can add all your plugins as git submodules and update
all of them with a single command.</p>

<p>Hermes uses the git submodule pattern: because every plugin can be kept in a single folder thanks to Pathogen, it's possible to add it as a submodule in the <code>hermes/vim/bundle</code> folder. This makes it dead easy to add other plugins when needed:</p>

<pre><code>cd ~/.hermes
git submodule add &lt;github-url&gt; hermes/vim/bundle/&lt;plugin-name&gt;
</code></pre>

<p>And you're done! In a similar fashion, updating plugins is also straightforward</p>

<pre><code>cd ~/.hermes
git submodule foreach git pull origin master
</code></pre>

<p>As in every other github based project, it's advisable to fork a plugin if you need to make changes that go beyond simple configuration (which we usually add to <code>~/.hermes/vim/plugins.vim</code>). In that case, you need to remove the original submodule and add it back again using your fork as a url.</p>

<p>Pathogen loads the content of <code>~/.vim/bundle</code> by default. including itself. This is controlled by the first two lines in the <code>~/.vimrc</code> file:</p>

<pre><code>" loading pathogen at runtime as it's bundled
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect()
</code></pre>

<h4>Managing configuration</h4>

<p>If you keep extending your <code>.vimrc</code>, it comes to a point where it's simply too long, so it makes sense to split it into separate chunks that are somewhat related: here's a sample from the bottom of my <code>.vimrc</code>:</p>

<pre><code>source $HOME/.vim/autocommands.vim
source $HOME/.vim/plugins.vim
source $HOME/.vim/shortcuts.vim
</code></pre>

<p>As a bonus, pressing <code>gf</code> in normal mode will open the file under the cursor.</p>

<p>In addition, always take care of reading the documentation for the plugins you use, as they're usually extremely configurable (an example is the <code>plugins.vim</code>) file.</p>

<p>Documentation is usually available by typing <code>:help &lt;term-to-search&gt;</code>, however Hermes has a custom shortcut you can use: by pressing <code>&lt;leader&gt;h</code> with the cursor on a word, it will search the help docs for the word itself.</p>

<p>Plugin configuration is vital in the long run, as the purpose of plugins should be to help you, not getting in your way.</p>

<p>As an example, let's look at the configuration Hermes supplies for Ctrl-p (in <code>~/.hermes/hermes/vim/plugins.vim</code>):</p>

<pre><code>set wildignore+=*/.hg/*,*/.svn/*,*/vendor/cache/*,*/public/system/*,*/tmp/*,*/log/*,*/.git/*,*/.jhw-cache/*,*/solr/data/*,*/node_modules/*,*/.DS_Store
</code></pre>

<p>The <code>wildignore</code> flag is not Ctrl-p specific, as it's used by Vim for a lot autocompletion and expansion functions: the more we remove paths and files it's unlikely we want to parse, the better Vim will perform. And as Ctrl-p uses this pattern to determine a baseline for excluding files to create its index, by setting it right we keep it snappy.</p>

<h4>Daily use cases</h4>

<p>Here are a few examples of what you can do with Vim, bearing in mind that this is not meant to be an exhaustive guide. Instead, we will focus on recurring tasks that usually pop up during a normal workday.</p>

<h5>Shelling out</h5>

<p>Having the shell at your disposal can speed up your workflow tenfold, but to really take advantage of this it's important to learn how to alternate between Vim and the command line.</p>

<p>Sometimes you just need to run a simple shell command, like creating a directory or touching a file. In that situation, press <code>:</code> in normal mode to enter the command mode. Then type <code>!</code> to tell Vim to shell out and perform the command in the shell. So, if you want to create a <code>sample</code> directory, you can type:</p>

<pre><code>:!mkdir sample
</code></pre>

<p>The command will be performed in the current working directory, you can verify that with <code>:pwd</code>.</p>

<p>When you need to step out the file you're editing, perform a few tasks and then go back, your best option is to suspend Vim with <code>ctrl-z</code> and then resume it with <code>fg</code> when you're done. This is a very straightforward approach, widely used in the Unix world. It works out of the box and has no other requirements.</p>

<p>Alternatively, you can use a different window or pane with Tmux, as we're detailing in chapter XXX.</p>

<p>As always, you can associate a shortcut for a shell command you want to run: a good example is creating a leader command to run the current file as a spec.</p>

<pre><code>noremap &lt;leader&gt;s :!bundle exec rspec %&lt;cr&gt;
</code></pre>

<p>We use <code>noremap</code> to tell vim to create a key map for normal mode, assign it to <code>&lt;leader&gt;s</code> and then specify the command, a simple <code>bundle exec rspec</code> where we press the current file as an argument and then press enter (carriage return).</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-201102-21");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
